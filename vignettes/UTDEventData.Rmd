---
title: "UTDEventData: Extracting and aggregating event data from the UTD server"
author: 
- name: "Dr. Patrick T. Brandt"
  affiliation: &utd The University of Texass at Dallas
  email: pbrandt@utdallas.edu
- name: "Dr. Vito D'Orazio"
  affiliation: *utd
  email: dorazio@utdallas.edu
- name: "Hyoungah (Kate) Kim"
  affiliation: *utd
  email: hyoungah.kim@utdallas.edu
- name: "Jared Looper" 
  affiliation: *utd
  email: jrl140030@utdallas.edu
- name: "Micheal J. Shoemate" 
  affiliation: *utd
  email: michael.shoemate@utdallas.edu

package: UTDEventData
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{UTDEventData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This R package helps a user to extract a data set from the UTD Event Data server. The project of the UTDEventData R package is in progress and has been upadated day by day. Your comments, feedback, and suggestions are welcome to develop it.
If you have questions in using the package, please contact Kate Kim (<hyoungah.kim@utdallas.edu>) at UTD.  

This package requires you to have an API key to access to the UTD data server. Please find the following link and fill out the form to obtain an API key: <http://eventdata.utdallas.edu/signup>. 

You can install the package from the UTDEVentData github page in R with the following syntax.
```{r, eval = FALSE}
# install the package without the vignette
devtools::install_github("KateHyoung/UTDEventData")

# install the package with the vignette
devtools::install_github("KateHyoung/UTDEventData", build_vignettes=TRUE)
```


The UTD Event Data server has the five different event data tables. 

      Table 1:  Data Table Information           
Data Table         | Timeline          |  Further Information
-------------------| :----------------:|--------------------
Phoenix RT         | Oct. 2017 - Today | [OEDA](http://openeventdata.org/)
ICEWS              | 1995 - Sep.2016   | [ICEWS Dataverse](https://dataverse.harvard.edu/dataverse/icews)
Cline Phoenix NYT  | 1945 - 2005       | [Cline Center](http://www.clinecenter.illinois.edu/data/event/phoenix/)
Cline Phoenix FBIS | 1945 - 2005       | [Cline Center](http://www.clinecenter.illinois.edu/data/event/phoenix/)
Cline Phoenix SWB  | 1979 - 2015       | [Cline Center](http://www.clinecenter.illinois.edu/data/event/phoenix/)


The web links of each table provides the details of database and their entities and attributes. 

### computer enviroments this package has tested
The codes/functions in this documentation have been tested in the following versions of:

  - Microsoft Open R 3.4.0 
  - R-3.4.3 for Windows (32/64 bit)
  - OS X 10.12.2
  - R-2.4.3 for Mac
  
  
&nbsp;

# Functions

## Searching functions

There are two main searching functions in this package for users to look up the name of data table and the list of variables each data table contains.  

`DataTables()` returns the all data table names in the UTD server. 
```{r,eval = FALSE}
# Direct way as inputing an API key
DataTables(api_key = " ")
"'PHOENIX_RT', 'CLINE_PHOENIX_SWB', 'CLINE_PHOENIX_FBIS', 'CLINE_PHOENIX_NYT', 'ICEWS'"

# Save an API key as a string value and use it so as not to repeat typing the key string in other functions
k<-"...api key...."
DataTables(k)
"'PHOENIX_RT', 'CLINE_PHOENIX_SWB', 'CLINE_PHOENIX_FBIS', 'CLINE_PHOENIX_NYT', 'ICEWS'"
```

`tableVar()` returns the list of variables in a particulr data table a user specified in the function. For example, the variables in the PHOENIX real-time data can be obtained with the following code. 

```{r, eval = FALSE}
tableVar(api_key="...", table="phoenix_rt")

# By using the saved API key to avoid the repeation of API key typing 
k<-"...api key...."
tableVar(k, "Phoenix_rt")

tableVar(k, "Icews")

tableVar(k, "Cline_Phoenix_swb")
```

This function is not case sensitive, so a user may type either lower case or upper case of data table name. However, the full name as returned by `Table()` should be specified in the function. For instance, `"cline_Phoenix_swb"` and `"CLINE_PHOENIX_SWB"` will return the same variables, but `"cline_phenix"` will return noting. 

This function has another feature as being enable a user to look up a particular variable (attribute) in a data table. For example, one who may wonder the ICEWS data have a variable named "target" can type the string of the certain variable as follows;

```{r, eval = FALSE }
tableVar(api_key="...", table="icews", lword="target")

k <- "..api key..."
tableVar(k, table="icews", lword="target")
" Target Name"    " Target Sectors", ....
```


&nbsp;

## Subsetting function I

`pullData()` returns a subset of data from a data table according to the information of country names and time ranges a user provides to the function. Please note the corresponding time period of a certain data in Table 1. If the given time range in the function falls outside the timeline of a data table, the function will return `list()` as its result. 

Please confirm the format of time range, which is "YYYYMMDD."     
The country names can be either full names or the ISO-Alpha3 code. Please use a consistent format when you type countries names. We recommend the ISO code format to reduce systemic error in the function.  

The function returns the citation texts of publication and Bibtex formats at the end of data retrieval. If you do not want to have it, please turn off the option by choosig "FALSE" in the 'citation' option. 

The following code is the possible examples you may use to obtain a subset of data. 

```{r, eval = FALSE}
pullData(api_key=" ", table_name="Phoenix_rt", country=list("USA","MEX","SYR","CHN"), start="20171101", end="20171112", citation = TRUE)

## When you avoid repeating an API key into the function
k<-'api key...'
subset1 <- pullData(k, "phoenix_rt", list('canada','China'), '20171101', '20171102')
subset2 <- pullData(k, "icews", list('can', 'usa'), '20010101','20010110')
subset3 <- pullData(k, 'cline_Phoenix_NYT',list('South Korea','canada'), '19551105','19581215')

# without citation
pullData(k, "phoenix_rt", list('canada','China'), '20171101', '20171102', citation = FALSE)
```


### Reference class for appying an API key to the functions 

The pacakge has a reference class, named `Table()` for users not to repeat the input of an API key into the searching and subsettng functions. Once a referece class is set, a user does not need to repeatedly put an API key into a function. Some basic usage is as follows;

```{r, eval=FALSE}
# Creating an object
obj<-Table$new()

# Setting an object of an API key
obj$setAPIKey("....")
obj$DataTables()  # returns the available data tables in the UTD server
obj$tableVar("cline_Phoenix_NYT")

# when a user wants to subset real-time data ('phoenix_rt) from 20171101 to 20171102 on MEX(Mexico)
obj$pullData("Phoenix_rt", list("MEX"),start="20171101", end="20171102")
```
You can apply a reference class on the functions of `DataTables()`, `TableVar()`, and `pullData()`. 

&nbsp;

## Data citation function

`citeData()` function returns the texts of publication citations of the Event data at the UTD server. The returns contains two different type of citations; 1) a text type citation for a user to copy and paste the text to jouranl paper drafits or other documents, and 2) a Bibtex type for \Latex users. The input of table names is case-insensitive, but you should have full data table names for the function input. 

```{r, eval = FALSE}
# citations for Cline Phoenix Event data
citeData(table_name = "cline_Phoenix_swb")

# citations for UTD real-time data 
citeData(table_name = "Phoenix_rt")

# citations for ICEWS  
citeData(table_name = "ICEWS")
```

&nbsp;

## Subsetting functions II

The package provides another way to obtain subsets from the API server. These  functions require users to have an API key to obtain data but provide more options in subsetting criteria.  For instance, While `pullData()` function provides limited query options such as country names and time ranges of a data set, the group of subsetting functions II provides users more discretion of query blocks such as contry names, time ranges, dyads of actors, latitute and longitude of event locations. and source and targets indications of certain events. By using combined query blocks, users can retrieve data with various criteria.  The query blocks can be crated and stored by its specific functions in the package. To obtain data avoid error massages, user must acquaint each function's usage illustrated in the help pages. The details how individual function works together with the other functions will be illustrated in this section.  

The subsetting function II in the package consists of three groups. The first group of subsetting function II is creating qeury blocks according to user's interests. The subsetting query blocks are the basis of subsetting information such as country names, locations (latitude and longitude), time ranges, and so on. Moreover, a user can use any variable (attributes) in an API data table with the regular expression function, `returnRegExp()`. The second group of the subsetting function II is connective functions of query blocks such as `orList()` and `andList()`. These functions play a role like a logical operatior on combining query blocks. The third part of the subsetting function II functions is requesting data based on the query a user creates to the API server. 

### Query block functions

`returnCountries()` is the function that creates the list of countreis names. The function requires users to specify a data table name and country names. The ISO-3 Code format is recommended for the country names, but full country names can work in the function. The inputs are case-insensitive. 

```{r, eval = FALSE}
# generating a query of the United States and Canada as a country restraint
ctr <- returnCounries("phoenix_rt", list("USA","CAN"))
```   

`returnTimes()` is the function that generates a query to return all events between specified time ranges. The format of input time should be "YYYYMMDD" in the order of start and end of a time range. A user mush indentify a data table in the function. 

```{r, eval = FALSE}
# generates a query to return all events between the dates July 27, 1980, and December 10, 2004
time <- returnCounries(table_name,  "19800727", "20041210")
``` 

`returnLatLon()` returns the geo-location boundary a user specif with latitudes and longitudes. This function does not require a data table name, but the input should be ordered by `lat1, lat2, log1, log2`. They are respectively the minimum and maximum values of latitudes and minimum and maximum values of longtigudes for a target boundary. 

```{r, eval = FALSE}
# generate a query with a geo-location bountry with the longitude between -80 and 30 and the longitude between 20 and 80
q <- returnLatLon(-80,30,20,80)
```

The `returnDyad()` function creates a query of particular dyads of actors of countreis involved in political events. In the function, a user must specify a table name and source and target countries repectively. ISO3 codes for country names is recomended as function inputs, but full names of countries also work in this funtion. These inputs are not case-sensitive. 

```{r, eval = FALSE}
# genrate a query that a source country is Syria and a target country is the United States
dyad <- returnDayd(table_name, "SYR", "USA")
```

`returnRegExp()` returns a regular expression with variables in the API data table. To use this function, a user must understand the variable in a certain data table. The variable list in a particular table can be found with the function of `tableVar()` in the package. The function requirs users to provide an API key, and a data table name, a pattern of interest events, and a field name in the data table. 

```{r, eval = FALSE}
# genrate a query for all source actors that involved in governments in events
others <- returnRegExp( api_key, table_name,"GOV","Source Name")
```


## Connectivive functions 

These functions play a role to connecting several queries created by query block funcctions aforementioned. The two functions, `andList()` and `orList()`, work as logical operators, **"and"** and **"or"**, respectively.  

`andList()` is the function that returns subset of two or more query lists. The stored queries should be specified in the `list()` format in the function. 

`orList()` returns a union of two or more query lists in a set thoery. The stored queries should be specified in the `list()` format in the function. 

```{r, eval = FALSE}
# combine stored query blocks such as 'time' or 'q' created before
and_query <- andList(list(q,time))

# subset with two or more stored query blocks such as 'q' or 'dyad'
or_query <- orList(list(q,dyad))
```



## Data request function

A data set can be retreived with the combinations generated with aforementioned functions. The `sendQuery()` function requests specified data to the API server. A user should input an API key, a data table, and a list of queries created by `andList()` or `orList()`  in the function as shown in the following example code. 



```{r, eval = FALSE}
# request a data set with the list of created queries 
sendQuery(api_key, tabl_name, and_query)

# examples of subsetting functions

# creating query blocks
# a country constrain of CHN and USA
k <- 'api_key'
ctr <- returnCountries("phoenix_rt",list("CHN", "USA"))

# the time range between 2017-11-1 and 2017-11-5
time <- returnTimes("phoenix_rt","20171101","20171105")

# A boolean logic, or, with the two query blocks
or_query <- orList(list(ctr, time))
# request a data set to the API server
d1 <- sendQuery(k,"phoenix_rt",or_query)

# A boolean logic, and, with the two query blocks
and_query <- andList(list(ctr, time))
d2 <- sendQuery(k,"phoenix_rt",and_query)

# When a user wants to extract all event in US and China with the events for which the source was a government actor from the Phoenix real-time table
rgex<- returnRegExp(k, "phoenix_rt","GOV", "src_agent")
q <- andList(list(ctr, rgex))
data  <- sendQuery(k,"phoenix_rt",q)
```

Users can create thier own query blocks with the other functions such as `returnLocation()` and `returnDyad()`. They can combine them according to thier interest in order to obtain prefered data sets. 

Please note that an issue may occur if the large size of data are extracted by `sendQuery()`. More specifically, the issue can more frequently come with the `orList()` function, so using `orList()` with several query blocks may bring about the issue. Once the issue occurs, please increase a memory size allocated for your R program and re-run the functions. If a user keeps having the issue, please consider to use `pullData()` for data subsetting. `pullData()` works more efficiently than `sendQuery()`.  


### An error message from `sendQuery()` 
The aforementioned issue in  `sendQuery()` can occur when the size of requested data is greather than computer's memory. The error message will suggest a solution such as increasing a memory size of a user's computer with the original error note the R program returns. 

This issue is more frequently occured in a Windows machine because of the memory cap allocated to a R program. Once a user has the issue, `getQuerySize()` should be drawn to estimate data sizes. After comparing the size of data and machine' RAM, he/she may need to increae its maximum. 

please see the following examples

```{r, eval = FALSE}
# estimate the data size you want to extract
getQuerySize('api_key', 'table_name',query objecct)

# if the error message is noted, estimate the data a user has requested
getQuerySize(k, 'phoenix_rt', q)

# check your memory limit only in the Windows system
memory.limit()
# increase its size if you need 
memory.size(max=120000)   
```

&nbsp;

# Further information of the Event Data server at UTD

## Spec-real-time server
[Github page for the API access on Jetstream at UTD](https://github.com/Sayeedsalam/spec-event-data-server)  
This Github page provides specific information of the direct access to the UTD server managed by Big Data Management and Analytic Lab with Mongo DB query syntax. The queries are expressed in JSON format. 

## Jetstream
[Jetstream user guide](https://portal.xsede.org/jetstream)  
XSEDE user guide provides specific information of the Jetstream usage and its working system. You can explore other information of Jetstream in the linked websites. 

